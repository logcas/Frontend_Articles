# Node.js中内存机制

由于Node.js中的JS引擎是V8，因此，Node.js的垃圾清理机制也当然是V8的那一套。在一般的后端语言中，在基本的内存使用上没有什么限制，然而Node.js中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约1.4GB，32位系统下约0.7GB）。因此，Node.js无法直接操作一个大内存对象。

造成这个问题的主要原因在于Node.js基于V8构建，所以在Node.js中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理。V8这套内存房管机制在浏览器下使用肯定卓卓有余，因为在Web页面上用户停留的时间非常短暂，很快就刷新页面或者关闭页面。但在Node.js中，这实际上成了限制。

## V8的垃圾回收机制
V8的垃圾回收机制主要采用分代式回收机制，主要将内存分为**新生代**和**老生代**两部分。其中，**新生代**中的对象存活时间较短，而**老生代**中对象存活时间较长或常驻。

![](http://img.lxzmww.xyz/v8/%E5%A0%86%E7%A9%BA%E9%97%B4.jpg)

### Scavenge 算法
在分代的基础上，新生代中的对象主要通过Scavenge算法（具体实现采用了Cheney算法）进行垃圾回收。它是一种采用复制的方式实现的垃圾回收算法，它将新生代的内存空间一分为二，其中一个处于使用中的状态，而另一个处于闲置，前者称为`from`空间，后者称为`to`空间。

![](http://img.lxzmww.xyz/v8/Scavenge%E7%AE%97%E6%B3%95.jpg)

当我们在JavaScript中分配一个对象时，便会在堆中分配一个空间，而具体的位置，就是分配在新生代内存的`from`空间中。当开始进行垃圾回收时，会检查`from`空间中的存活对象，把存活对象都复制到`to`空间中。而非存活对象便会释放掉。完成全部存活对象的复制后，`from`空间便会清空，然后`from`空间和`to`空间便会交换职能，也就是`from`空间成为新的`to`空间，`to`空间成为新的`from`空间。

Scavenge算法的缺点是只能使用堆内存的一半，按上述所说，我们只能使用新生代空间中的一半作为`from`空间来给对象分配对应的内存空间。但由于新生代内存中`from`空间中的对象大多都是生命周期比较短的，因此即使通过复制交换，也能在性能和效率上表现得比较优异。

### 晋升
Scavenge算法用于处理新生代内存空间的内存管理问题，而老生代空间的定义是存放一些常驻的对象，这些对象的生命周期一般很长。

当一个对象经过多次Scavenge算法处理后依然存在，它将会被认为是生命周期较长的对象，这时它将会被复制到老生代空间中，这种操作成为**晋升**。

一般来说，对象晋升有两种触发的方式：
1. 它时候经历过Scavenge算法的回收
2. `to`空间的内存占用比超过25%

![](http://img.lxzmww.xyz/v8/%E6%99%8B%E5%8D%87.jpg)

### Mark-Sweep 标记清理
由于老生代空间存放的都是生命周期较长的对象，因此在每次进行垃圾回收时，活跃对象的比重很大。如果这时候继续使用Scavenge算法的话，会出现两个很致命的问题：
1. 存活对象过多，使用复制的话效率太低。
2. Scavenge算法需要把空间一分为二，只能使用老生代空间的一般。

很显然，Scavenge算法已经不适用于处理老生代空间的内存问题。为此，V8在老生代空间中主要使用`Mark-Sweep`（标记清理）来进行垃圾回收。

`Mark-Sweep`分为两个阶段：标记和清理。`Mark-Sweep`在标记阶段遍历老生代空间中的所有对象，并标记所有存活的对象，然后在清理阶段，只清理未标记对象。可以看到，`Mark-Sweep`算法的好处是不需要对内存中的存活对象进行复制，而是直接清理。

但是，`Mark-Sweep`的缺点也是很明显的，就是内存碎片问题。在经过一次`Mark-Sweep`标记清理后，老生代空间中存在很多不连续的内存碎片，这些碎片可能会影响后续对象的晋升（如果一个晋升对象占用内存很大，任何一个内存碎片都不满足要求）。

因此，在老生代空间中，除了使用标记清理外，还需要通过`Mark-Compact`去配合。

### Mark-Compact 标记整理
为了解决标记清理产生的碎片问题，`Mark-Compact`被提出来辅助`Mark-Sweep`。它们的差别在于把对象标记为死亡后，在整理的过程中，将存活对象往一端移动，移动完成后，直接清理掉边界外的内存。

### Incremental Marking 增量标记
在JavaScript进行垃圾回收处理时，都需要将应用的逻辑停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为成为“全停顿”。对于老生代内存中的对象，由于生命周期较长，且存活对象多，全堆垃圾回收的标记、清理、整理等动作造成停顿需要的时间可能较长，如果因此而造成应用逻辑的全停顿，会影响应用的正常运行。

因此，为了解决这个问题，V8从标记阶段入手，把原来要一口气完成的动作改为“增量标记”的形式，也就是拆分为许多小的步骤，每完成一个步骤就让JS引用逻辑执行一小会儿，垃圾回收和应用逻辑交替执行直到标记阶段完成。

![](http://img.lxzmww.xyz/v8/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0.JPG)
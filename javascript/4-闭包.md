# JavaScript中的闭包
在JS中，闭包是一个非常重要，但是理解难度比较大的一个东西。它作用广泛，几乎任何地方都会使用到。看了不少介绍文章，但是发现都会真正说明闭包产生的原因，顺着这个东西，我就谈谈我对闭包的理解。上次面试也被问到了闭包的问题，面试官是这么问的：“说一说闭包”。实际上我觉得，闭包的定义千奇百怪，很难用一句话去形容，很多都是理解了但是很难描述出来，就算描述出来又因为各自的定义不一。所以我还是觉得深入去了解闭包的形成原因，至于闭包是怎么定义的，就各有各的说法了。

## 从表面看什么是闭包
从表面上看，假如我们定义了一个函数A，里面有一个局部变量a，然后我们再在函数A中定义一个函数B，在函数B中我们打印局部变量a的值，最终我们返回函数B，使它挂载到全局上：
```js
function A() {
  var a = 666;
  function B() {
    console.log(a);
  }
  return B;
}
var _B = A();
_B(); // 666
```

如果我们不用闭包，我们是无法从外层的作用域中访问函数A中的局部变量的，而内部的函数却可以访问到外部作用域的变量。闭包所解决的问题，就是使得我们可以访问某个函数中的局部变量。就如上面的代码那样，我们可以同通过返回的函数B去访问函数A的局部变量。

## 从起源上看闭包
如果我们在函数A中没有返回函数B，那么，在函数A执行完后，函数A的执行上下文就会从执行栈中弹出，而局部变量a和函数B所占的内存空间就会被垃圾回收机制收回。但是我们返回了函数B，并挂载到了一个全局变量上，那么，局部变量a的函数B所占的空间就不会被清空掉。

为了了解闭包的形成原因，我们需要了解到，当我们访问一个变量的时候，究竟是如何访问的到的。

实际上我们都知道，每一个函数作用域中都存在一个作用域链。作用域链实际上就是一个上层作用域的引用的集合。

我们回到这段代码，逐一解析作用域链的问题。

```js
var c = 999;
function A() {
  var a = 666;
  console.log(c);
  function B() {
    console.log(a);
  }
  return B;
}
var _B = A();
_B(); // 666
```

当我们执行了`A()`时，就会为函数A创建一个执行上下文，这时候就会确定作用域链。由于JavaScript使用的是词法作用域，也就是静态作用域，因此，它的作用域链是在函数定义时确定的，而不是执行时，因此，此时函数A的执行上下文是这样的：
```js
FunctionAContext = {
  AO,
  this,
  [[Scope]] = [globalContext]
}
```

因为函数A定义在全局作用域中，因此，它的作用域链中只有一个作用域：全局作用域。

现在我们执行函数A中的代码，第一句是`var a = 666;`，它会修改AO中的属性a，但是这里我们并不详细说这点，我们需要围绕作用域链去说。

继续执行，执行`console.log(c);`。执行到这句，会体现作用域链的存在价值，因为当我们访问变量c时，实际上是这样访问的：
1. 查找函数A的AO（活动对象），看有没有变量`c`，没有。
2. 然后遍历作用域链`[[Scope]]`，查找变量`c`。
3. 因此，先查找`[[Scope]]`中的第一个上层作用域，是`globalContext`，查找它的VO（变量对象），发现在全局作用域中定义了变量`c`，找到。
4. 打印变量`c`。

继续执行，执行到定义函数B。

继续执行，返回函数B，函数A的执行上下文出栈。

继续执行，把函数B作为返回值挂载到全局作用域下的全局变量`_B`中。

继续执行，执行_B，也就是执行函数B。这时候会创建函数B的执行上下文，压入执行栈的栈顶。这时候函数B的执行上下文是这样的：

```js
FunctionBContext = {
  AO,
  this,
  [[Scope]] = [FunctionAContext, globalContext]
}
```

我们可以看到，函数B的执行上下文中，作用域链有两个对象，依次是函数A的作用域、全局作用域。

继续执行，打印变量a。跟前面说到一样，当我们访问变量a时，整个过程是这样的：
1. 查找函数B的AO（活动对象），看有没有变量`a`，没有。
2. 然后遍历作用域链`[[Scope]]`，查找变量`a`。
3. 因此，先查找`[[Scope]]`中的第一个上层作用域，是`FunctionAContext`，查找它的VO（变量对象），发现在全局作用域中定义了变量`a`，找到。
4. 打印变量`a`。

前面我们说过，一般来说，当我们执行完一个函数，把它的执行上下文弹出执行栈后，这个函数中的局部变量所占的空间会被收回。但是由于闭包的存在，在外部还保存着内部函数作用域中变量的引用，它依然可以保留下来，不会被处理掉。

因从我觉得，闭包的核心实际上就是通过作用域的层层搜索，保留了局部变量的引用，从而阻止了它的回收，这才形成了闭包。假如我们不通过作用域链，而是直接返回一个它的值，实际上只是一个拷贝而已：
```js
function A() {
  var a = 666;
  return a;
}
var b = A();
console.log(b); // 666，但只是一个值拷贝
```

```js
function A() {
  var a = 666;
  return {
    a
  }
}
var b = A();
console.log(b.a); // 666，但也只是一个值拷贝
```

上面这两种情况，实际上函数A中的局部变量a已经被回收，只是在返回时拷贝了一份。

闭包一定要返回一个函数去形成吗？**不一定的**，我们来看看下面这段代码：
```js
let add;
function A() {
  var a = 666;
  add = function() {
    ++a;
  };
  return function() {
    console.log(a);
  };
}
let b = A();
b(); // 666
add();
b(); // 667
```

我们现在都知道，我们返回了一个函数，并且这个函数中存在对上层作用域的引用，它形成了一个闭包。但是`add`是闭包吗？**答案是肯定的**。

当我们执行`add()`的时候，照上面的一样，创建一个函数执行上下文，压栈，然后是这样的：
```js
FunctionAddContext = {
  AO,
  this,
  [[Scope]] = [FunctionAContext, globalContext]
}
```

而寻找变量a的过程，实际上是差不多的，也是通过作用域链：
1. 查找函数add的AO（活动对象），看有没有变量`a`，没有。
2. 然后遍历作用域链`[[Scope]]`，查找变量`a`。
3. 因此，先查找`[[Scope]]`中的第一个上层作用域，是`FunctionAContext`，查找它的VO（变量对象），发现在全局作用域中定义了变量`a`，找到。
4. 对变量`a`自增。

由于修改的是`FunctionAContext`的变量，因此，`FunctionAContext`中的变量对象也发生了变化：

原来是这样的：
```js
FunctionAContext = {
  VO ={
    a: 666
  },
  this,
  [[Scope]] = [globalContext]
}
```

现在变成了这样：
```js
FunctionAContext = {
  VO ={
    a: 667
  },
  this,
  [[Scope]] = [globalContext]
}
```

然后，当我们再次执行函数b时，它通过作用域链去访问函数A中的变量a，得到了肯定就是`667`了。

# 总结
闭包这个东西，有时候真的是只能意会，因为每个人的定义不一。但实际上理解的东西是相同的，只是描述的方式不同而已。我对闭包的理解就是：一个函数它可以通过作用域链去访问其他作用域的变量，这就形成了闭包。当然，我的描述可能不准确，但是更加需要注重的其实是理解。
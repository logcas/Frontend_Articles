# TCP 传输控制协议
TCP（传输控制协议）是一个面向连接的运输层的网络协议，为应用层提供可靠传输。

两端在使用TCP进行数据传输前，都需要先进行连接；在数据传输之后，断开连接。因此，TCP并不支持一对多和多对多的广播，而仅仅是一对一的，面向连接的、可靠的传输。

## 可靠性
TCP通过以下方式来提供传输的可靠性：
1. 应用层下发到运输层的数据，会被分割成TCP认为最适合发送的数据块。由TCP传递给IP的信息单位称为报文段或段(segment)。
2. 当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段。如果在规定时间内未收到对端的确认，即为超时，TCP将会重新发送这个报文段，并且重新启动定时器。
3. TCP收到另一端的数据，将会发送一个确认。但这个确认不是立即发送，通常将推迟几分之一秒，提高网络的利用率。
4. TCP将保持它的首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输的过程中的任何变化。如果收到的检验和有差错，TCP将丢弃这个报文并且不回应确认，因此等待发送端的重新发送。
5. TCP报文段作为IP数据包来传输，而IP数据包的到达可能失序，因此TCP的报文段的到达也可能会失序。如果有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确顺序交给应用层。
6. TCP的接收端会丢弃重复的数据。
7. TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止块主机致使慢主机的缓冲区溢出。

## 流
TCP通过字节流进行传输，并且不对字节流的内容作任何解释。TCP不知道传输的数据字节流是二进制还是ASCII字符等其他数据类型。对字节流的解释由TCP连接双方的应用层解释。

## TCP首部
TCP报文段的首部如下，如果选项字段为空，不设置任何其他值，则TCP的首部通常为20字节。
![](http://img.lxzmww.xyz/tcp/header.png)

其中，6个标志位分别如下：
![](http://img.lxzmww.xyz/tcp/mark.png)

## 建立连接——三报文握手
![](http://img.lxzmww.xyz/tcp/TCP%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B.jpg)

一般情况下，TCP都会进行三报文握手，以建立TCP连接：
1. 请求端（客户端）发送一个SYN报文，报文中指明客户都安打算连接的服务器端口，初始序号（ISN），如图中的`seq = x`，并且设置SYN端为1。发送后，客户端进入`SYS_SENT`状态。
2. 服务器发送包含服务器的初始需要的SYN报文作为应答，同时要设置确认序号（客户的ISN+1，如图中的`ack = x + 1`）进行SYN报文段的取人。一个SYN将占用一个序号。发送后，客户端进入`SYS_RECEIVED`状态。
3. 客户必须将确认需要设置为服务器的ISN加1以对服务器的SYN报文进行确认。发送后，客户端进入`ESTABLISHED`状态；服务端在接收到这个报文后，同样进入`ESTABLISHED`状态。

经过上述三个报文的传输，TCP连接就建立了。

### 老生常谈的问题
1. 为什么TCP握手需要三次，两次行不行？
答案是不行。虽然说两次报文握手后，实际上也可以建立连接。但是，如果失去了第三次报文的握手，假设第一次握手，客户端发送的SYN报文在网络中超时，但没有被丢弃，客户端又重新发送了一个到服务端，等到客户端和服务端完成连接、数据传输完成、断开连接后，原来第一次握手的报文又到达了服务端，这时服务端又会建立一个连接。但是，此时客户端已经不需要了，而服务端因为这个幽灵报文而建立TCP连接，白白浪费了服务端资源。
2. 如果两端同时主动请求，怎么办？
这个可能性极小，但是还是会有的。这时候，会比正常的三次握手多一次握手，并且，由于双方都是主动连接态，因此，状态也会有所不同。
![](http://img.lxzmww.xyz/tcp/TCP%E5%9B%9B%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B.jpg)

## 断开连接——四报文握手
一般情况下，断开TCP连接时要进行四报文握手。因此TCP是全双工链路，因此，可以看成：每次断开都是一个半连接的断开，需要两个报文。而全连接的断开，则需要断开两个半连接。
![](http://img.lxzmww.xyz/tcp/TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B.jpg)

1. 客户端主动断开连接，向服务端发送FIN报文，并且指明序号`seq = u`，发送到服务端后，进入`FIN_WAIT_1`状态。
2. 服务端收到后，发送ACK报文进行响应，指明确认号`ack = u + 1`，发送到客户端后，进入`CLOSE_WAIT`状态，客户端收到后，进入`FIN_WAIT_2`状态，此时，客户端到服务端的连接链路断开，客户端不能再向服务端发送数据，但可以接收来自服务端的TCP报文段（因为TCP是支持半连接的）。
3. 服务端向客户端发送完剩余的数据后，向客户端发送FIN报文，并且指明序号`seq = v`，发送到客户端后，进入`LAST_ACK`状态。
4. 客户端接收后，响应ACK报文，指明确认号`ack = v + 1`。发送后等到2MSL时间后，客户端进入`CLOSE`状态。服务端接收后，进入`CLOSE`状态。握手结束。

### 老生常谈的问题
1. 为什么要四次握手，三次不行吗？
理论上，三次握手也是可能的。假如客户端到服务端的连接断开后，服务端并没有数据再要发送到客户端，第二次和第三次的报文可以合成一个报文，因此，三次握手也是可能的。
2. 为什么客户端第四次握手要等待2MSL时间再关闭？
MSL意思为最大报文段生存时间。等待2MSL可以确保第四次握手的报文可以顺利到达服务端被服务端接收，使服务端进入`CLOSE`状态。如果没有了这段时间，假如报文在传输的过程中丢失，将使服务端不能正常关闭；等待2MSL可以使报文超时或丢失时客户端重发报文。

## 拥塞控制
谈到拥塞控制，就要先谈谈拥塞的因素和本质。本质上，网络上拥塞的原因就是大家都想独享整个网络资源，对于TCP，端到端的流量控制必然会导致网络拥堵。这是因为TCP只看到对端的接收空间的大小，而无法知道链路上的容量，只要双方的处理能力很强，那么就可以以很大的速率发包，于是链路很快出现拥堵，进而引起大量的丢包，丢包又引发发送端的重传风暴，进一步加剧链路的拥塞。另外一个拥塞的因素是链路上的转发节点，例如路由器，再好的路由器只要接入网络，总是会拉低网络的总带宽，如果在路由器节点上出现处理瓶颈，那么就很容易出现拥塞。由于TCP看不到网络的状况，那么拥塞控制是必须的并且需要采用试探性的方式来控制拥塞，于是拥塞控制要完成两个任务：**公平性**和**拥塞过后的恢复**。

TCP发展到现在，拥塞控制方面的算法很多，其中Reno是目前应用最广泛且较为成熟的算法，下面着重介绍一下Reno算法(RFC5681)。介绍该算法前，首先介绍一个概念duplicate acknowledgment(冗余ACK、重复ACK)。

一般情况下一个ACK被称为冗余ACK，要同时满足下面几个条件(对于SACK，那么根据SACK的一些信息来进一步判断)：

1. 接收ACK的那端已经发出了一些还没被ACK的数据包
2. 该ACK没有捎带data
3. 该ACK的SYN和FIN位都是off的，也就是既不是SYN包的ACK也不是FIN包的ACK。
4. 该ACK的确认号等于接收ACK那端已经收到的ACK的最大确认号
5. 该ACK通知的窗口等接收该ACK的那端上一个收到的ACK的窗口。

**Reno算法包含4个部分：**

1. 慢热启动算法 – Slow Start;
2. 拥塞避免算法 – Congestion Avoidance;
3. 快速重传 - Fast Retransimit;
4. 快速恢复算法 – Fast Recovery。

TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，根据前面的讨论，我们知道有一个接收端通告的接收窗口(rwnd)用于流量控制；加上拥塞控制后，发送端真正的发送窗口=min(rwnd, cwnd)。关于cwnd的单位，在TCP中是以字节来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据，因此你可以认为cwnd按照数据包个数来做单位也可以理解，下面如果没有特别说明是字节，那么cwnd增加1也就是相当于字节数增加1个MSS大小。

### 1 慢热启动算法 – Slow Start
慢启动体现了一个试探的过程，刚接入网络的时候先发包慢点，探测一下网络情况，然后在慢慢提速。不要一上来就拼命发包，这样很容易造成链路的拥堵，出现拥堵了在想到要降速来缓解拥堵这就有点成本高了，毕竟无数的先例告诫我们先污染后治理的成本是很高的。

慢启动的算法如下(cwnd全称Congestion Window)：

1. 连接建好的开始先初始化cwnd = N，表明可以传N个MSS大小的数据。
2. 每当收到一个ACK，++cwnd; 呈线性上升
3. 每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
4. 还有一个慢启动门限ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入"拥塞避免算法 - Congestion Avoidance"。

根据RFC5681，如果MSS > 2190 bytes，则N = 2;如果MSS < 1095 bytes，则N = 4;如果2190 bytes >= MSS >= 1095 bytes，则N = 3;一篇Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》建议把cwnd 初始化成了 10个MSS。Linux 3.0后采用了这篇论文的建议。

### 2 拥塞避免算法 – Congestion Avoidance

慢启动的时候说过，cwnd是指数快速增长的，但是增长是有个门限ssthresh(一般来说大多数的实现ssthresh的值是65535字节)的，到达门限后进入拥塞避免阶段。

在进入拥塞避免阶段后，cwnd值变化算法如下：

1. 每收到一个ACK，调整cwnd 为 (cwnd + 1/cwnd) * MSS个字节；
2. 每经过一个RTT的时长，cwnd增加1个MSS大小。

TCP是看不到网络的整体状况的，那么TCP认为网络拥塞的主要依据是它重传了报文段。

前面我们说过TCP的重传分两种情况：

1. 出现RTO超时，重传数据包。这种情况下，TCP就认为出现拥塞的可能性就很大，于是它反应非常'强烈'：
  * 调整门限ssthresh的值为当前cwnd值的1/2；
  * reset自己的cwnd值为1；
  * 然后重新进入慢启动过程。
2. 在RTO超时前，收到3个duplicate ACK进行重传数据包。这种情况下，收到3个冗余ACK后说明确实有中间的分段丢失，然而后面的分段确实到达了接收端，因为这样才会发送冗余ACK，这一般是路由器故障或者轻度拥塞或者其它不太严重的原因引起的，因此此时拥塞窗口缩小的幅度就不能太大，此时进入快速重传。

快速重传 - Fast Retransimit


### 快速重传

1. 调整门限ssthresh的值为当前cwnd值的1/2；
2. 将cwnd值设置为新的ssthresh的值；
3. 重新进入拥塞避免阶段。

在快速重传的时候，一般网络只是轻微拥堵，在进入拥塞避免后，cwnd恢复的比较慢。针对这个，“快速恢复”算法被添加进来，当收到3个冗余ACK时，TCP最后的3步骤进入的不是拥塞避免阶段，而是快速恢复阶段。

### 快速恢复算法 – Fast Recovery

快速恢复的思想是“数据包守恒”原则，即带宽不变的情况下，在网络同一时刻能容纳数据包数量是恒定的。当“老”数据包离开了网络后，就能向网络中发送一个“新”的数据包。既然已经收到了3个冗余ACK，说明有三个数据分段已经到达了接收端，既然三个分段已经离开了网络，那么就是说可以在发送3个分段了。于是只要发送方收到一个冗余的ACK，于是cwnd加1个MSS。

快速恢复步骤如下(在进入快速恢复前，cwnd 和 sshthresh已被更新为：sshthresh = cwnd /2，cwnd = sshthresh)：

1. 把cwnd设置为ssthresh的值加3，重传Duplicated ACKs指定的数据包
2. 如果再收到 duplicated Acks，那么cwnd = cwnd +1
3. 如果收到新的ACK，而非duplicated Ack，那么将cwnd重新设置为1的sshthresh的值。然后进入拥塞避免状态。

细心的同学可能会发现快速恢复有个比较明显的缺陷就是：它依赖于3个冗余ACK，并假定很多情况下，3个冗余的ACK只代表丢失一个包。但是3个冗余ACK也很有可能是丢失了很多个包，快速恢复只是重传了一个包，然后其他丢失的包就只能等待到RTO超时了。超时会导致ssthresh减半，并且退出了Fast Recovery阶段，多个超时会导致TCP传输速率呈级数下降。出现这个问题的主要原因是过早退出了Fast Recovery阶段。为解决这个问题，提出了New Reno算法，该算法是在没有SACK的支持下改进Fast Recovery算法(SACK改变TCP的确认机制，把乱序等信息会全部告诉对方，SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包)。

具体改进如下：

1. 发送端收到3个冗余ACK后，重传冗余ACK指示可能丢失的那个包segment1，如果segment1的ACK通告接收端已经收到发送端的全部已经发出的数据的话，那么就是只丢失一个包，如果没有，那么就是有多个包丢失了；
2. 发送端根据segment1的ACK判断出有多个包丢失，那么发送端继续重传窗口内未被ACK的第一个包，直到sliding window内发出去的包全被ACK了，才真正退出Fast Recovery阶段。

我们可以看到，拥塞控制在拥塞避免阶段，cwnd是加性增加的，在判断出现拥塞的时候采取的是指数递减。为什么要这样做呢？这是出于公平性的原则，拥塞窗口的增加受惠的只是自己，而拥塞窗口减少受益的是大家。这种指数递减的方式实现了公平性，一旦出现丢包，那么立即减半退避，可以给其他新建的连接腾出足够的带宽空间，从而保证整个的公平性。

## 参考
* [不为人知的网络编程(二)：浅析TCP协议中的疑难杂症(下篇)](http://www.52im.net/thread-1004-1-1.html)
* [TCP/IP详解 卷1：协议](http://www.52im.net/topic-tcpipvol1.html)